// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: csp-e2e.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ## End-to-End Encrypted Messages (Supplementary)
//
// This is a supplementary section to the corresponding structbuf section
// with newer messages that use protobuf instead of structbuf. All defined
// messages here follow the same logic.

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Metadata sent within a CSP payload `message-with-metadata-box` struct.
public struct CspE2e_MessageMetadata {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Padding that is ignored by the receiver.
  /// Recommended to be chosen such that the total length of padding + nickname
  /// is at least 16 bytes. May be empty if the nickname is long enough.
  public var padding: Data = Data()

  /// Unique message ID. Must match the message ID of the outer struct
  /// (i.e. `message-with-metadata-box.message-id`).
  public var messageID: UInt64 = 0

  /// Unix-ish timestamp in milliseconds for when the message has been created.
  ///
  /// Messages sent in a group must have the same timestamp for each group
  /// member.
  public var createdAt: UInt64 = 0

  /// Nickname
  ///
  /// Should be sent when the associate message requires _user profile
  /// distribution_.
  ///
  /// When the user cleared its nickname, send an empty string. Do not send the
  /// user's Threema ID (i.e. process data).
  ///
  /// Recommended to not exceed 32 grapheme clusters. Should not contain
  /// whitespace characters at the beginning or the end of string.
  public var nickname: String {
    get {return _nickname ?? String()}
    set {_nickname = newValue}
  }
  /// Returns true if `nickname` has been explicitly set.
  public var hasNickname: Bool {return self._nickname != nil}
  /// Clears the value of `nickname`. Subsequent reads from it will return its default value.
  public mutating func clearNickname() {self._nickname = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _nickname: String? = nil
}

/// Edit an existing message (e.g. a text message or a media message caption).
///
/// **Properties (1:1)**:
/// - Kind: 1:1
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: No
/// - Exempt from blocking: No
/// - Implicit _direct_ contact creation: No
/// - Protect against replay: Yes
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts:
///   - Automatic: No
///   - Manual: No
/// - Edit applies to: N/A (obviously)
/// - Deletable by: N/A
/// - When rejected: N/A (ignored)
/// - Send to Threema Gateway ID group creator: N/A
///
/// **Properties (Group)**:
/// - Kind: Group
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: No
/// - Exempt from blocking: No
/// - Implicit _direct_ contact creation: No
/// - Protect against replay: Yes
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts:
///   - Automatic: N/A
///   - Manual: No
/// - Edit applies to: N/A (obviously)
/// - Deletable by: N/A
/// - When rejected: N/A (ignored)
/// - Send to Threema Gateway ID group creator: If capture is enabled
///
/// The following steps must be invoked when the user wants to edit a 1:1
/// message:
///
/// 1. If the sender or the receiver do not have `EDIT_MESSAGE_SUPPORT`, disallow
///    editing and abort these steps.
/// 2. Run the _Common Edit Message Enter Steps_.
/// 3. Allow the user to edit the referred message.
///
/// The following steps must be invoked when the user wants to edit a group
/// message:
///
/// 1. If the group is marked as _left_, disallow editing and abort these steps.
/// 2. If the sender or all of the group members do not have
///    `EDIT_MESSAGE_SUPPORT`, disallow editing and abort these steps.
/// 3. Run the _Common Edit Message Enter Steps_.
/// 4. If any of the group members do not have `EDIT_MESSAGE_SUPPORT`, notify the
///    user that the affected contacts will not receive the edited content.
/// 5. Allow the user to edit the referred message.
///
/// The following steps are defined as the _Common Edit Message Enter Steps_:
///
/// 1. Let `message` be the referred message.
/// 2. If the user is not the original sender of `message`, disallow editing and
///    abort these steps.
/// 3. If `message` has been sent (`sent-at`) more than 6 hours ago, disallow
///    editing and abort these steps.¹
///
/// The following steps must be invoked when the user wants to submit an edited
/// 1:1 message.
///
/// 1. If the sender or the receiver do not have `EDIT_MESSAGE_SUPPORT`, discard
///    the edited message and abort these steps.
/// 2. Run the _Common Edit Message Submit Preflight Steps_.
/// 3. Let `edit-message-id` be a random message ID.
/// 4. Let `edited-at` be the current timestamp.
/// 5. Schedule a persistent task to run the _Bundled Messages Send Steps_ with
///    the following properties:
///    - `id` set to `edit-message-id`,
///    - `created-at` set to `edited-at`,
///    - `receivers` set to the receiver,
///    - to construct an `EditMessage` message
/// 6. Edit `message` as defined by the associated _Edit applies to_ property and
///    add an indicator to `message`, informing the user that the message has
///    been edited by the user at `edited-at`.
///
/// The following steps must be invoked when the user wants to submit an edited
/// group message.
///
/// 1. If the group is marked as _left_, discard the edited message and abort
///    these steps.
/// 2. If the sender or all of the group members do not have
///    `EDIT_MESSAGE_SUPPORT`, discard the edited message and abort these steps.
/// 3. Run the _Common Edit Message Submit Preflight Steps_.
/// 4. Let `edit-message-id` be a random message ID.
/// 5. Let `edited-at` be the current timestamp.
/// 6. Schedule a persistent task to run the _Bundled Messages Send Steps_ with
///    the following properties:
///    - `id` set to `edit-message-id`,
///    - `created-at` set to `edited-at`,
///    - `receivers` set to all group members that have `EDIT_MESSAGE_SUPPORT`,
///    - to construct an `EditMessage` message (wrapped by
///      [`group-member-container`](ref:e2e.group-member-container))
/// 7. Edit `message` as defined by the associated _Edit applies to_ property and
///    add an indicator to `message`, informing the user that the message has
///    been edited by the user at `edited-at`.
///
/// The following steps are defined as the _Common Edit Message Submit Preflight
/// Steps_:
///
/// 1. Lookup the message with `message_id` originally sent by the sender within
///    the associated conversation and let `message` be the result.
/// 2. If `message` is no longer defined, discard the edited message and abort
///    these steps.
/// 3. If the content of `message` is identical to the edited message, discard
///    the edited message and abort these steps.
///
/// When reflected from another device as an incoming or outgoing 1:1 message:
///
/// 1. Run the _Common Edit Message Receive Steps_.
///
/// When receiving this message as a 1:1 message:
///
/// 1. Run the _Common Edit Message Receive Steps_.
///
/// When reflected from another device as an incoming or outgoing group message:
///
/// 1. Run the _Common Edit Message Receive Steps_.
///
/// When receiving this message as a group message (wrapped by
/// [`group-member-container`](ref:e2e.group-member-container)):
///
/// 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the message
///    has been discarded, abort these steps.
/// 2. Run the _Common Edit Message Receive Steps_.
///
/// The following steps are defined as the _Common Edit Message Receive Steps_:
///
/// 1. Lookup the message with `message_id` originally sent by the sender within
///    the associated conversation and let `message` be the result.
/// 2. If `message` is not defined or the sender is not the original sender of
///    `message`, discard the message and abort these steps.²
/// 3. If `message` is not editable (see the associated _Edit applies to_
///    property), discard the message and abort these steps.
/// 4. Edit `message` as defined by the associated _Edit applies to_ property and
///    add an indicator to `message`, informing the user that the message has
///    been edited by the sender at the `message`'s `created-at`.
///
/// ¹: For simplicity, the time constraint is applied on the sender side only.
/// The receiver will always accept a request to edit a message. This is deemed
/// acceptable considering this is not a security feature.
///
/// ²: Implementations do not track the group member setup at the time a message
/// was received. Therefore, an edited message is always sent to the **current**
/// group member setup, including any group members that weren't part of the
/// group when the message was sent. However, any ordinary client will discard
/// `EditMessage` for unknown messages. This leak is not great but considered
/// acceptable for now.
public struct CspE2e_EditMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of the referred message to be edited.
  public var messageID: UInt64 = 0

  /// Text (or caption) to update the referred message with. Should be ≤ 6000
  /// bytes.
  public var text: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Remove an existing message.
///
/// Note: This is a soft-security feature at best and it applies a best effort
/// approach, meaning that it relies on some level of good will on the receiving
/// end. A malicious receiver can easily persist a message prior to removal by
/// e.g. making a screenshot, forwarding it, changing the date, explicitly saving
/// it (if it contains media), etc.
///
/// **Properties (1:1)**:
/// - Kind: 1:1
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: No
/// - Exempt from blocking: No
/// - Implicit _direct_ contact creation: No
/// - Protect against replay: Yes
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts:
///   - Automatic: No
///   - Manual: No
/// - Edit applies to: N/A
/// - Deletable by: N/A (obviously)
/// - When rejected: N/A (ignored)
/// - Send to Threema Gateway ID group creator: N/A
///
/// **Properties (Group)**:
/// - Kind: Group
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: No
/// - Exempt from blocking: No
/// - Implicit _direct_ contact creation: No
/// - Protect against replay: Yes
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts:
///   - Automatic: N/A
///   - Manual: No
/// - Edit applies to: N/A
/// - Deletable by: N/A (obviously)
/// - When rejected: N/A (ignored)
/// - Send to Threema Gateway ID group creator: If capture is enabled
///
/// The following steps must be invoked when the user wants to delete a 1:1
/// message:
///
/// 1. If the sender or the receiver do not have `DELETE_MESSAGE_SUPPORT`,
///    disallow removal and abort these steps.
/// 2. Run the _Common Delete Message Preflight Steps_.
/// 3. Let `delete-message-id` be a random message ID.
/// 4. Let `deleted-at` be the current timestamp.
/// 5. Schedule a persistent task to run the _Bundled Messages Send Steps_ with
///    the following properties:
///    - `id` set to `delete-message-id`,
///    - `created-at` set to `deleted-at`,
///    - `receivers` set to the receiver,
///    - to construct a `DeleteMessage` message
/// 6. Replace `message` with a message informing the user that the message of
///    the user has been removed at `deleted-at`.²
///
/// The following steps must be invoked when the user wants to delete a group
/// message.
///
/// 1. If the group is marked as _left_, disallow removal and abort these steps.
/// 2. If the sender or all of the group members do not have
///    `DELETE_MESSAGE_SUPPORT`, disallow removal and abort these steps.
/// 3. Run the _Common Delete Message Preflight Steps_.
/// 4. If any of the group members do not have `DELETE_MESSAGE_SUPPORT`, notify
///    the user that the affected contacts will continue to see the message.
/// 5. Let `delete-message-id` be a random message ID.
/// 6. Let `deleted-at` be the current timestamp.
/// 7. Schedule a persistent task to run the _Bundled Messages Send Steps_ with
///    the following properties:
///    - `id` set to `delete-message-id`,
///    - `created-at` set to `deleted-at`,
///    - `receivers` set to all group members that have `DELETE_MESSAGE_SUPPORT`,
///    - to construct an `DeleteMessage` message (wrapped by
///      [`group-member-container`](ref:e2e.group-member-container))
/// 8. Replace `message` with a message informing the user that the message of
///    the user has been removed at `deleted-at`.²
///
/// The following steps are defined as the _Common Delete Message Preflight
/// Steps_:
///
/// 1. Let `message` be the referred message.
/// 2. If the user is not the original sender of `message`, disallow removal and
///    abort these steps.
/// 3. If `message` has been sent (`sent-at`) more than 6 hours ago, disallow
///    removal and abort these steps.¹
///
/// When reflected from another device as an incoming or outgoing 1:1 message:
///
/// 1. Run the _Common Delete Message Receive Steps_.
///
/// When receiving this message as a 1:1 message:
///
/// 1. Run the _Common Delete Message Receive Steps_.
///
/// When reflected from another device as an incoming or outgoing group message:
///
/// 1. Run the _Common Delete Message Receive Steps_.
///
/// When receiving this message as a group message (wrapped by
/// [`group-member-container`](ref:e2e.group-member-container)):
///
/// 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the message
///    has been discarded, abort these steps.
/// 2. Run the _Common Delete Message Receive Steps_.
///
/// The following steps are defined as the _Common Delete Message Receive Steps_:
///
/// 1. Lookup the message with `message_id` originally sent by the sender within
///    the associated conversation and let `message` be the result.
/// 2. If `message` is not defined or the sender is not the original sender of
///    `message`, discard the message and abort these steps.
/// 3. If `message` is not deletable (see the associated _Deletable by_
///    property), discard the message and abort these steps.
/// 4. Replace `message` with a message informing the user that the message of
///    the sender has been removed at the `message`'s `created-at`.²
///
/// ¹: For simplicity, the time constraint is applied on the sender side only.
/// The receiver will always accept a request to delete a message. This is deemed
/// acceptable considering this is just barely a soft-security feature.
///
/// ²: All references to a removed message (e.g. quotes) must be updated as well,
/// so that the message content is no longer visible. An implementation should
/// also try to withdraw or update any notification created for a removed
/// message.
public struct CspE2e_DeleteMessage {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Unique ID of the referred message to be removed.
  public var messageID: UInt64 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

/// Announces and immediately starts a group call.
///
/// **Properties**:
/// - Kind: Group
/// - Flags:
///   - `0x01`: Send push notification.
/// - User profile distribution: Yes
/// - Exempt from blocking: Yes
/// - Implicit _direct_ contact creation: No
/// - Protect against replay: Yes
/// - Reflect:
///   - Incoming: Yes
///   - Outgoing: Yes
///   - _Sent_ update: No
/// - Delivery receipts:
///   - Automatic: N/A
///   - Manual: No
/// - When rejected: N/A¹
/// - Edit applies to: N/A
/// - Deletable by: N/A
/// - Send to Threema Gateway ID group creator: If capture is enabled
///
/// ¹: For the group creator it will be handled as if `group-sync-request` was
/// received, re-sending a `GroupCallStart` if still ongoing, implicitly
/// triggered by FS `Reject` receive steps.
///
/// When reflected from another device as an incoming or outgoing message:
///
/// 1. Run the _Common Group Call Start Receive Steps_.
///
/// When receiving this message:
///
/// 1. Run the [_Common Group Receive Steps_](ref:e2e#receiving). If the message
///    has been discarded, abort these steps.
/// 2. Run the _Common Group Call Start Receive Steps_.
///
/// The following steps are defined as the _Common Group Call Start Receive
/// Steps_:
///
/// 1. If the hostname of `sfu_base_url` does not use the scheme `https` or does
///    not end with one of the set of [_Allowed SFU Hostname
///    Suffixes_](ref:group-calls#obtain-sfu-information), log a warning, discard
///    the message and abort these steps.
/// 2. Let `running` be the list of group calls that are currently considered
///    running within the group.
/// 3. If another call with the same GCK exists in `running`, log a warning,
///    discard the message and abort these steps.
/// 4. Add the received call to the list of group calls that are currently
///    considered running (even if `protocol_version` is unsupported¹).
/// 5. Start a task to run the _Group Call Refresh Steps_.²
///
/// ¹: Adding unsupported `protocol_version`s allows the user to join an ongoing
///  call after an app update where support for `protocol_version` has been
///  added.
///
/// ²: This ensures that the user automatically switches to the chosen call if it
/// is currently participating in a group call of this group.
public struct CspE2e_GroupCallStart {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  /// Protocol version used for group calls of this group. The current version
  /// number is `1`.
  ///
  /// Note: This is a _major_ version and may only be increased in case of
  /// breaking changes due to the significant UX impact this has when running the
  /// _Common Group Receive Steps_ (i.e. only calls with supported protocol
  /// versions can be _chosen_).
  public var protocolVersion: UInt32 = 0

  /// The secret Group Call Key (`GCK`) used for this call.
  public var gck: Data = Data()

  /// The base URL of the SFU, used to join or peek the call.
  public var sfuBaseURL: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

#if swift(>=5.5) && canImport(_Concurrency)
extension CspE2e_MessageMetadata: @unchecked Sendable {}
extension CspE2e_EditMessage: @unchecked Sendable {}
extension CspE2e_DeleteMessage: @unchecked Sendable {}
extension CspE2e_GroupCallStart: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "csp_e2e"

extension CspE2e_MessageMetadata: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".MessageMetadata"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "padding"),
    3: .standard(proto: "message_id"),
    4: .standard(proto: "created_at"),
    2: .same(proto: "nickname"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBytesField(value: &self.padding) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self._nickname) }()
      case 3: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      case 4: try { try decoder.decodeSingularUInt64Field(value: &self.createdAt) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if !self.padding.isEmpty {
      try visitor.visitSingularBytesField(value: self.padding, fieldNumber: 1)
    }
    try { if let v = self._nickname {
      try visitor.visitSingularStringField(value: v, fieldNumber: 2)
    } }()
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 3)
    }
    if self.createdAt != 0 {
      try visitor.visitSingularUInt64Field(value: self.createdAt, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_MessageMetadata, rhs: CspE2e_MessageMetadata) -> Bool {
    if lhs.padding != rhs.padding {return false}
    if lhs.messageID != rhs.messageID {return false}
    if lhs.createdAt != rhs.createdAt {return false}
    if lhs._nickname != rhs._nickname {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2e_EditMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EditMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
    2: .same(proto: "text"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.text) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 1)
    }
    if !self.text.isEmpty {
      try visitor.visitSingularStringField(value: self.text, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_EditMessage, rhs: CspE2e_EditMessage) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.text != rhs.text {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2e_DeleteMessage: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".DeleteMessage"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "message_id"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularFixed64Field(value: &self.messageID) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.messageID != 0 {
      try visitor.visitSingularFixed64Field(value: self.messageID, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_DeleteMessage, rhs: CspE2e_DeleteMessage) -> Bool {
    if lhs.messageID != rhs.messageID {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension CspE2e_GroupCallStart: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".GroupCallStart"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "protocol_version"),
    2: .same(proto: "gck"),
    3: .standard(proto: "sfu_base_url"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularUInt32Field(value: &self.protocolVersion) }()
      case 2: try { try decoder.decodeSingularBytesField(value: &self.gck) }()
      case 3: try { try decoder.decodeSingularStringField(value: &self.sfuBaseURL) }()
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.protocolVersion != 0 {
      try visitor.visitSingularUInt32Field(value: self.protocolVersion, fieldNumber: 1)
    }
    if !self.gck.isEmpty {
      try visitor.visitSingularBytesField(value: self.gck, fieldNumber: 2)
    }
    if !self.sfuBaseURL.isEmpty {
      try visitor.visitSingularStringField(value: self.sfuBaseURL, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: CspE2e_GroupCallStart, rhs: CspE2e_GroupCallStart) -> Bool {
    if lhs.protocolVersion != rhs.protocolVersion {return false}
    if lhs.gck != rhs.gck {return false}
    if lhs.sfuBaseURL != rhs.sfuBaseURL {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
